res_plus_k <- query_wikidata(gsub("Q75900", "Q289590", q_plus), format = "simple")
nrow(res_plus_k); head(res_plus_k, 20)
q_plus <- "
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
SELECT (STRAFTER(STR(?item),'entity/') AS ?item) ?itemLabel WHERE {
VALUES ?root { wd:Q75900 }      # Stefan Quandt
?root (wdt:P22|wdt:P25)+ ?item .
SERVICE wikibase:label { bd:serviceParam wikibase:language 'en'. }
}"
res_plus <- query_wikidata(q_plus, format = "simple")
nrow(res_plus); head(res_plus, 200)
# Try Susanne Klatten too
res_plus_k <- query_wikidata(gsub("Q75900", "Q289590", q_plus), format = "simple")
nrow(res_plus_k); head(res_plus_k, 200)
wiki_list <- tibble::tibble(id_wikidata = c("Q75900","Q289590"))
# Container
df_wiki <- tibble::tibble(item = character(), itemLabel = character(),
root = character(), rootLabel = character())
# SPARQL templates (normalize to QIDs with STRAFTER)
sparql_query01 <- "SELECT (STRAFTER(STR(?item),'entity/') AS ?item) ?itemLabel (STRAFTER(STR(?root),'entity/') AS ?root) ?rootLabel WHERE { VALUES ?root { wd:"
sparql_query02 <- " } ?root (wdt:P22|wdt:P25)+ ?item .
SERVICE wikibase:label { bd:serviceParam wikibase:language 'en,de'. } } ORDER BY DESC(?item)"
for (i in seq_len(nrow(wiki_list))) {
x <- wiki_list$id_wikidata[[i]]
message(sprintf("[%s/%s] root: %s", i, nrow(wiki_list), x))
q_text <- paste0(sparql_query01, x, sparql_query02)
df_single <- tryCatch({
WikidataQueryServiceR::query_wikidata(q_text, format = "simple") %>%
dplyr::select(dplyr::any_of(c("item","itemLabel","root","rootLabel"))) %>%
dplyr::mutate(dplyr::across(dplyr::everything(), as.character))
},
error = function(e) {
message("   ⚠️ SPARQL error for ", x, ": ", conditionMessage(e))
tibble::tibble(item=character(), itemLabel=character(), root=character(), rootLabel=character())
}
)
df_wiki <- dplyr::bind_rows(df_wiki, df_single) %>% dplyr::distinct()
Sys.sleep(0.25)
}
save(df_wiki, file = "data_prepared/fam_members_richies2019.RData")
# Sanity
nrow(df_wiki); head(df_wiki, 10)
ua <- "elite-ancestry-r/0.1 (your_email@example.com)"
if ("set_user_agent" %in% getNamespaceExports("WikidataQueryServiceR")) {
WikidataQueryServiceR::set_user_agent(ua)
} else {
options(WikidataQueryServiceR.user_agent = ua)
}
library(WikidataQueryServiceR)
# 1) Do they have P22/P25 at all (immediate parents)?
q_parents <- "
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
SELECT ?p ?pLabel WHERE {
VALUES ?root { wd:Q75900 }          # Stefan Quandt
?root (wdt:P22|wdt:P25) ?p .
SERVICE wikibase:label { bd:serviceParam wikibase:language 'en'. }
}"
parents_quandt <- query_wikidata(q_parents, format = "simple")
nrow(parents_quandt); parents_quandt
q_parents_klatten <- gsub("Q75900", "Q289590", q_parents)
parents_klatten <- query_wikidata(q_parents_klatten, format = "simple")
nrow(parents_klatten); parents_klatten
q_plus <- "
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
SELECT (STRAFTER(STR(?item),'entity/') AS ?item) ?itemLabel WHERE {
VALUES ?root { wd:Q75900 }      # Stefan Quandt
?root (wdt:P22|wdt:P25)+ ?item .
SERVICE wikibase:label { bd:serviceParam wikibase:language 'en'. }
}"
res_plus <- query_wikidata(q_plus, format = "simple")
nrow(res_plus); head(res_plus, 20)
# Try Susanne Klatten too
res_plus_k <- query_wikidata(gsub("Q75900", "Q289590", q_plus), format = "simple")
nrow(res_plus_k); head(res_plus_k, 20)
rm(list = ls())
#taws final check
work_dir <- "~/Desktop/Elite Population Research"
dir.create(file.path(work_dir, "data_prepared"), showWarnings = FALSE, recursive = TRUE)
setwd(work_dir)
pkgs <- c("readxl","writexl","tidyverse","stringr","igraph","SPARQL")
lapply(pkgs[!(pkgs %in% installed.packages())], install.packages)
invisible(lapply(pkgs, library, character.only = TRUE))
work_dir <- "~/Desktop/Elite Population Research"
setwd(work_dir)
dir.create("data_prepared", showWarnings = FALSE, recursive = TRUE)
getwd()
# Packages
pkgs <- c(
"readxl",
"writexl",
"tidyverse",
"WikidataR",
"stringr",
"igraph"
)
## Install uninstalled packages
lapply(pkgs[!(pkgs %in% installed.packages())], install.packages)
install.packages("WikidataQueryServiceR")
#taws final check
wdqs_query <- function(q, ua = UA, endpoint = endpoint, tries = 4L, sleep0 = 1) {
delay <- sleep0
for (k in seq_len(tries)) {
out <- try(SPARQL::SPARQL(endpoint, q, curl_args = list(httpheader = c("User-Agent" = ua)))$results, silent = TRUE)
if (!inherits(out, "try-error")) return(out)
msg <- paste(out)
message(sprintf("   ⚠️ WDQS error (try %d/%d): %s", k, tries, msg))
Sys.sleep(delay); delay <- delay * 2
}
data.frame()
}
is_human <- function(qid) {
q <- sprintf("
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
SELECT ?root WHERE { VALUES ?root { wd:%s } ?root wdt:P31 wd:Q5 . } LIMIT 1", qid)
nrow(wdqs_query(q)) > 0
}
has_parents <- function(qid) {
q <- sprintf("
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
SELECT ?p WHERE { VALUES ?root { wd:%s } ?root (wdt:P22|wdt:P25) ?p . } LIMIT 1", qid)
nrow(wdqs_query(q)) > 0
}
# quick connectivity smoke test
smoke <- wdqs_query("
SELECT ?l WHERE { wd:Q42 rdfs:label ?l . FILTER (lang(?l)='en') } LIMIT 1
")
if (!nrow(smoke)) stop("Endpoint not reachable; UA or network issue.")
## Load all packages to library
lapply(pkgs, library, character.only = TRUE)
library(WikidataQueryServiceR)
# Individuals on rich list 2019
df = read_excel("data/wikidata2019.xlsx")
# how many wikidata entries? 439
df_test = df  %>% filter(!is.na(id_wikidata)) %>%
select(id_wikidata, id_fam, name) %>%
distinct(id_wikidata, .keep_all = TRUE)
# representing how many families?
length(unique(df_test$id_fam)) # 394 families
remove(df_test)
wdqs_query <- function(q, ua = UA, endpoint = endpoint, tries = 4L, sleep0 = 1) {
delay <- sleep0
for (k in seq_len(tries)) {
out <- try(SPARQL::SPARQL(endpoint, q, curl_args = list(httpheader = c("User-Agent" = ua)))$results, silent = TRUE)
if (!inherits(out, "try-error")) return(out)
msg <- paste(out)
message(sprintf("   ⚠️ WDQS error (try %d/%d): %s", k, tries, msg))
Sys.sleep(delay); delay <- delay * 2
}
data.frame()
}
is_human <- function(qid) {
q <- sprintf("
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
SELECT ?root WHERE { VALUES ?root { wd:%s } ?root wdt:P31 wd:Q5 . } LIMIT 1", qid)
nrow(wdqs_query(q)) > 0
}
has_parents <- function(qid) {
q <- sprintf("
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
SELECT ?p WHERE { VALUES ?root { wd:%s } ?root (wdt:P22|wdt:P25) ?p . } LIMIT 1", qid)
nrow(wdqs_query(q)) > 0
}
# quick connectivity smoke test
smoke <- wdqs_query("
SELECT ?l WHERE { wd:Q42 rdfs:label ?l . FILTER (lang(?l)='en') } LIMIT 1
")
if (!nrow(smoke)) stop("Endpoint not reachable; UA or network issue.")
library(SPARQL)
---- Part 2: Get info of all family members (roots only) ----
## ---- Part 2: Get info of all family members (roots only) ----
# 0) Prep
suppressPackageStartupMessages({
library(tidyverse)
library(WikidataQueryServiceR)
})
if (!exists("df")) df <- readxl::read_excel("data/wikidata2019.xlsx")
endpoint <- "https://query.wikidata.org/sparql"  # used by the package internally
# 1) QIDs to enrich: all non-NA id_wikidata
all_qids <- df %>%
dplyr::filter(!is.na(id_wikidata)) %>%
dplyr::distinct(id_wikidata) %>%
dplyr::pull(id_wikidata)
# 2) Keep only humans (instance of human: Q5) — batched VALUES filter
batch_vals <- function(vec, size = 80) split(vec, ceiling(seq_along(vec)/size))
human_qids <- character(0)
human_query_tpl <- "
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
SELECT (STRAFTER(STR(?item),'entity/') AS ?item) WHERE {
VALUES ?item { %s }
?item wdt:P31 wd:Q5 .
}"
for (b in batch_vals(all_qids, 80)) {
vals <- paste0("wd:", b, collapse = " ")
q <- sprintf(human_query_tpl, vals)
tmp <- tryCatch(
WikidataQueryServiceR::query_wikidata(q, format = "simple"),
error = function(e) tibble::tibble(item = character())
)
if (nrow(tmp)) human_qids <- c(human_qids, tmp$item)
Sys.sleep(0.15)
}
human_qids <- unique(human_qids)
# 3) Info query (batched) for humans
info_query_tpl <- "
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
SELECT
(STRAFTER(STR(?item),   'entity/') AS ?item)        ?itemLabel
(STRAFTER(STR(?father), 'entity/') AS ?father)      ?fatherLabel
(STRAFTER(STR(?mother), 'entity/') AS ?mother)      ?motherLabel
(STRAFTER(STR(?sibling),'entity/') AS ?sibling)     ?siblingLabel
(STRAFTER(STR(?relative),'entity/') AS ?relative)   ?relativeLabel
(STRAFTER(STR(?child),  'entity/') AS ?child)       ?childLabel
(STRAFTER(STR(?spouse), 'entity/') AS ?spouse)      ?spouseLabel
?genderLabel (YEAR(?birth_date) AS ?birth_year) (YEAR(?death_date) AS ?death_year)
WHERE {
VALUES ?item { %s }
OPTIONAL { ?item wdt:P1038 ?relative . }
OPTIONAL { ?item wdt:P40   ?child    . }
OPTIONAL { ?item wdt:P26   ?spouse   . }
OPTIONAL { ?item wdt:P22   ?father   . }
OPTIONAL { ?item wdt:P25   ?mother   . }
OPTIONAL { ?item wdt:P3373 ?sibling  . }
OPTIONAL { ?item wdt:P21   ?gender   . }
OPTIONAL { ?item wdt:P569  ?birth_date . }
OPTIONAL { ?item wdt:P570  ?death_date . }
SERVICE wikibase:label { bd:serviceParam wikibase:language 'de,en'. }
}
ORDER BY DESC(?item)
"
df_wiki_info <- tibble::tibble(
item=character(), itemLabel=character(),
father=character(), fatherLabel=character(),
mother=character(), motherLabel=character(),
sibling=character(), siblingLabel=character(),
relative=character(), relativeLabel=character(),
child=character(), childLabel=character(),
spouse=character(), spouseLabel=character(),
genderLabel=character(),
birth_year=character(), death_year=character()
)
for (b in batch_vals(human_qids, 50)) {
vals <- paste0("wd:", b, collapse = " ")
q <- sprintf(info_query_tpl, vals)
tmp <- tryCatch(
WikidataQueryServiceR::query_wikidata(q, format = "simple"),
error = function(e) tibble::tibble()
)
if (nrow(tmp)) {
tmp[] <- lapply(tmp, as.character)
# make sure all expected columns exist
miss <- setdiff(names(df_wiki_info), names(tmp))
if (length(miss)) tmp[miss] <- NA_character_
df_wiki_info <- dplyr::bind_rows(df_wiki_info, tmp[names(df_wiki_info)]) %>% dplyr::distinct()
}
Sys.sleep(0.15)
}
# 4) Save + sanity checks
dir.create("data_prepared", showWarnings = FALSE)
save(df_wiki_info, file = "data_prepared/rich2019_with_info.RData")
cat("\n---- PART 2 SANITY ----\n")
cat("Total human roots:   ", length(human_qids), "\n")
cat("Info rows returned:  ", nrow(df_wiki_info), "\n")
print(df_wiki_info %>%
dplyr::summarise(
n_items = dplyr::n_distinct(item),
with_father = sum(!is.na(father)),
with_mother = sum(!is.na(mother)),
with_spouse = sum(!is.na(spouse)),
with_child  = sum(!is.na(child))
))
cat("\nSample:\n")
print(head(df_wiki_info, 12))
suppressPackageStartupMessages({
library(tidyverse)
library(WikidataQueryServiceR)
library(readxl)
})
# Load df if not present
if (!exists("df")) df <- readxl::read_excel("data/wikidata2019.xlsx")
# Distinct QIDs from your file
all_qids <- df %>%
dplyr::filter(!is.na(id_wikidata)) %>%
dplyr::distinct(id_wikidata) %>%
dplyr::pull(id_wikidata)
# Quick sanity on what we're sending
cat("Total QIDs found in file:", length(all_qids), "\n")
print(head(all_qids, 12))
# Batch helper
batch_vals <- function(vec, size = 40) split(vec, ceiling(seq_along(vec)/size))
# Info query template (works for people and non-people; optionals fill when present)
info_query_tpl <- "
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
SELECT
(STRAFTER(STR(?item),   'entity/') AS ?item)        ?itemLabel
(STRAFTER(STR(?father), 'entity/') AS ?father)      ?fatherLabel
(STRAFTER(STR(?mother), 'entity/') AS ?mother)      ?motherLabel
(STRAFTER(STR(?sibling),'entity/') AS ?sibling)     ?siblingLabel
(STRAFTER(STR(?relative),'entity/') AS ?relative)   ?relativeLabel
(STRAFTER(STR(?child),  'entity/') AS ?child)       ?childLabel
(STRAFTER(STR(?spouse), 'entity/') AS ?spouse)      ?spouseLabel
?genderLabel (YEAR(?birth_date) AS ?birth_year) (YEAR(?death_date) AS ?death_year)
WHERE {
VALUES ?item { %s }
OPTIONAL { ?item wdt:P1038 ?relative . }
OPTIONAL { ?item wdt:P40   ?child    . }
OPTIONAL { ?item wdt:P26   ?spouse   . }
OPTIONAL { ?item wdt:P22   ?father   . }
OPTIONAL { ?item wdt:P25   ?mother   . }
OPTIONAL { ?item wdt:P3373 ?sibling  . }
OPTIONAL { ?item wdt:P21   ?gender   . }
OPTIONAL { ?item wdt:P569  ?birth_date . }
OPTIONAL { ?item wdt:P570  ?death_date . }
SERVICE wikibase:label { bd:serviceParam wikibase:language 'de,en'. }
}
ORDER BY DESC(?item)
"
# Output container
df_wiki_info <- tibble::tibble(
item=character(), itemLabel=character(),
father=character(), fatherLabel=character(),
mother=character(), motherLabel=character(),
sibling=character(), siblingLabel=character(),
relative=character(), relativeLabel=character(),
child=character(), childLabel=character(),
spouse=character(), spouseLabel=character(),
genderLabel=character(),
birth_year=character(), death_year=character()
)
# Fetch in batches
n_batches <- length(batch_vals(all_qids, 40))
b_i <- 0L
for (b in batch_vals(all_qids, 40)) {
b_i <- b_i + 1L
vals <- paste0("wd:", b, collapse = " ")
q <- sprintf(info_query_tpl, vals)
tmp <- tryCatch(
WikidataQueryServiceR::query_wikidata(q, format = "simple"),
error = function(e) {
message(sprintf("   ⚠️ batch %d error: %s", b_i, conditionMessage(e)))
tibble::tibble()
}
)
# If a batch comes back empty, try single-shot fallback for one known-good ID so we know the pipeline works:
if (nrow(tmp) == 0 && length(b) >= 1) {
q_test <- sprintf(info_query_tpl, paste0("wd:", b[1]))
tmp_test <- tryCatch(
WikidataQueryServiceR::query_wikidata(q_test, format = "simple"),
error = function(e) tibble::tibble()
)
message(sprintf("   batch %d returned %d rows; single-ID fallback returned %d rows",
b_i, nrow(tmp), nrow(tmp_test)))
# If singles work, append them now
if (nrow(tmp_test)) tmp <- dplyr::bind_rows(tmp, tmp_test)
}
if (nrow(tmp)) {
tmp[] <- lapply(tmp, as.character)
# ensure all expected columns exist
miss <- setdiff(names(df_wiki_info), names(tmp))
if (length(miss)) tmp[miss] <- NA_character_
df_wiki_info <- dplyr::bind_rows(df_wiki_info, tmp[names(df_wiki_info)]) %>% dplyr::distinct()
}
if (b_i %% 10 == 0) {
dir.create("data_prepared", showWarnings = FALSE)
save(df_wiki_info, file = "data_prepared/rich2019_with_info.RData")
message(sprintf("   ✓ checkpoint after batch %d/%d, rows: %d",
b_i, n_batches, nrow(df_wiki_info)))
}
Sys.sleep(0.2)  # be polite; bump if you see throttling
}
# Final save + sanity
dir.create("data_prepared", showWarnings = FALSE)
save(df_wiki_info, file = "data_prepared/rich2019_with_info.RData")
cat("\n---- PART 2 (NO HUMAN FILTER) SANITY ----\n")
cat("Info rows returned:  ", nrow(df_wiki_info), "\n")
print(df_wiki_info %>%
dplyr::summarise(
n_items = dplyr::n_distinct(item),
with_father = sum(!is.na(father)),
with_mother = sum(!is.na(mother)),
with_spouse = sum(!is.na(spouse)),
with_child  = sum(!is.na(child))
))
cat("\nSample:\n")
pr
# testtt
## ---- Part 2: Get info for ALL QIDs (no human filter) ----
suppressPackageStartupMessages({
library(tidyverse)
library(WikidataQueryServiceR)
library(readxl)
})
# Load df if not present
if (!exists("df")) df <- readxl::read_excel("data/wikidata2019.xlsx")
# Distinct QIDs from your file
all_qids <- df %>%
dplyr::filter(!is.na(id_wikidata)) %>%
dplyr::distinct(id_wikidata) %>%
dplyr::pull(id_wikidata)
# Quick sanity on what we're sending
cat("Total QIDs found in file:", length(all_qids), "\n")
print(head(all_qids, 12))
# Batch helper
batch_vals <- function(vec, size = 40) split(vec, ceiling(seq_along(vec)/size))
# Info query template (works for people and non-people; optionals fill when present)
info_query_tpl <- "
PREFIX wd:  <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
SELECT
(STRAFTER(STR(?item),   'entity/') AS ?item)        ?itemLabel
(STRAFTER(STR(?father), 'entity/') AS ?father)      ?fatherLabel
(STRAFTER(STR(?mother), 'entity/') AS ?mother)      ?motherLabel
(STRAFTER(STR(?sibling),'entity/') AS ?sibling)     ?siblingLabel
(STRAFTER(STR(?relative),'entity/') AS ?relative)   ?relativeLabel
(STRAFTER(STR(?child),  'entity/') AS ?child)       ?childLabel
(STRAFTER(STR(?spouse), 'entity/') AS ?spouse)      ?spouseLabel
?genderLabel (YEAR(?birth_date) AS ?birth_year) (YEAR(?death_date) AS ?death_year)
WHERE {
VALUES ?item { %s }
OPTIONAL { ?item wdt:P1038 ?relative . }
OPTIONAL { ?item wdt:P40   ?child    . }
OPTIONAL { ?item wdt:P26   ?spouse   . }
OPTIONAL { ?item wdt:P22   ?father   . }
OPTIONAL { ?item wdt:P25   ?mother   . }
OPTIONAL { ?item wdt:P3373 ?sibling  . }
OPTIONAL { ?item wdt:P21   ?gender   . }
OPTIONAL { ?item wdt:P569  ?birth_date . }
OPTIONAL { ?item wdt:P570  ?death_date . }
SERVICE wikibase:label { bd:serviceParam wikibase:language 'de,en'. }
}
ORDER BY DESC(?item)
"
# Output container
df_wiki_info <- tibble::tibble(
item=character(), itemLabel=character(),
father=character(), fatherLabel=character(),
mother=character(), motherLabel=character(),
sibling=character(), siblingLabel=character(),
relative=character(), relativeLabel=character(),
child=character(), childLabel=character(),
spouse=character(), spouseLabel=character(),
genderLabel=character(),
birth_year=character(), death_year=character()
)
# Fetch in batches
n_batches <- length(batch_vals(all_qids, 40))
b_i <- 0L
for (b in batch_vals(all_qids, 40)) {
b_i <- b_i + 1L
vals <- paste0("wd:", b, collapse = " ")
q <- sprintf(info_query_tpl, vals)
tmp <- tryCatch(
WikidataQueryServiceR::query_wikidata(q, format = "simple"),
error = function(e) {
message(sprintf("   ⚠️ batch %d error: %s", b_i, conditionMessage(e)))
tibble::tibble()
}
)
# If a batch comes back empty, try single-shot fallback for one known-good ID so we know the pipeline works:
if (nrow(tmp) == 0 && length(b) >= 1) {
q_test <- sprintf(info_query_tpl, paste0("wd:", b[1]))
tmp_test <- tryCatch(
WikidataQueryServiceR::query_wikidata(q_test, format = "simple"),
error = function(e) tibble::tibble()
)
message(sprintf("   batch %d returned %d rows; single-ID fallback returned %d rows",
b_i, nrow(tmp), nrow(tmp_test)))
# If singles work, append them now
if (nrow(tmp_test)) tmp <- dplyr::bind_rows(tmp, tmp_test)
}
if (nrow(tmp)) {
tmp[] <- lapply(tmp, as.character)
# ensure all expected columns exist
miss <- setdiff(names(df_wiki_info), names(tmp))
if (length(miss)) tmp[miss] <- NA_character_
df_wiki_info <- dplyr::bind_rows(df_wiki_info, tmp[names(df_wiki_info)]) %>% dplyr::distinct()
}
if (b_i %% 10 == 0) {
dir.create("data_prepared", showWarnings = FALSE)
save(df_wiki_info, file = "data_prepared/rich2019_with_info.RData")
message(sprintf("   ✓ checkpoint after batch %d/%d, rows: %d",
b_i, n_batches, nrow(df_wiki_info)))
}
Sys.sleep(2)  # be polite; bump if you see throttling
}
# Final save + sanity
dir.create("data_prepared", showWarnings = FALSE)
save(df_wiki_info, file = "data_prepared/rich2019_with_info.RData")
cat("\n---- PART 2 (NO HUMAN FILTER) SANITY ----\n")
cat("Info rows returned:  ", nrow(df_wiki_info), "\n")
print(df_wiki_info %>%
dplyr::summarise(
n_items = dplyr::n_distinct(item),
with_father = sum(!is.na(father)),
with_mother = sum(!is.na(mother)),
with_spouse = sum(!is.na(spouse)),
with_child  = sum(!is.na(child))
))
cat("\nSample:\n")
print(head(df_wiki_info, 12))
