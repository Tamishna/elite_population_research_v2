# Build nodes from edges + labels map
node_ids <- unique(c(edges$from, edges$to))
node_labels <- vapply(node_ids, function(q) labels[[q]] %||% NA_character_, FUN.VALUE = character(1))
nodes <- tibble::tibble(
node = node_ids,
nodeLabel = node_labels
)
list(edges = edges, nodes = nodes)
}
`%||%` <- function(x, y) if (is.null(x) || length(x) == 0L || is.na(x)) y else x
#### 2d. Merge seeds,dedupe and augmment with children ####
all_edges <- list()
all_nodes <- list()
cat(sprintf("Running parent-only ancestry on %d seed(s)\n", length(seeds)))
for (si in seq_along(seeds)) {
seed <- seeds[[si]]
cat(sprintf("[%d/%d] seed = %s\n", si, length(seeds), seed))
res <- tryCatch(
{ ancestors_for_seed(seed, max_depth = MAX_DEPTH) },
error = function(e) {
message("  !! Error on seed ", seed, ": ", conditionMessage(e))
return(NULL)
}
)
if (!is.null(res)) {
all_edges[[length(all_edges) + 1]] <- res$edges
# tag the seed itself for later grouping
res$nodes$is_seed <- res$nodes$node %in% seed
all_nodes[[length(all_nodes) + 1]] <- res$nodes
}
}
edges <- if (length(all_edges) > 0) dplyr::bind_rows(all_edges) else
tibble::tibble(from = character(), to = character(),
type = character(), fromLabel = character(), toLabel = character())
nodes <- if (length(all_nodes) > 0) dplyr::bind_rows(all_nodes) else
tibble::tibble(node = character(), nodeLabel = character(), is_seed = logical())
# Deduplicate
edges <- unique(edges)
nodes <- nodes %>%
group_by(node) %>%
summarize(
nodeLabel = dplyr::coalesce(dplyr::first(na.omit(nodeLabel)), NA_character_),
is_seed = any(is_seed, na.rm = TRUE),
.groups = "drop"
)
# Add group tag (seed vs ancestor)
nodes <- nodes %>%
mutate(group = ifelse(is_seed | node %in% df$id_wikidata, "rich 2019", "ancestor")) %>%
mutate(id = dplyr::row_number() - 1L,
nodeLabel2 = paste(nodeLabel, id))
# Minimal weights
edges$value <- 1L
# Remove duplicate edges by (from, to, type)
edges <- edges %>% distinct(from, to, type, .keep_all = TRUE)
#### 3. Horizontal relationships (spouse/sibling) ####
# We build sideways ties in two ways:
# (A) Inferred: spouse via co-parent, sibling via shared parent(s)
# (B) Direct:   P26 spouses, P3373 siblings from Wikidata
# We write separate CSVs per source and a merged "all sources" table.
# Print a summary before augmentation
cat("----\n")
cat(sprintf("Before augmentation → Nodes: %s | Edges: %s\n",
nrow(nodes), nrow(edges)))
# Augment the ancestor graph with children ===
aug <- augment_graph_with_children(edges, nodes)
edges <- aug$edges
# keep existing columns (group, is_seed, etc.) and only fill missing labels
nodes <- nodes %>%
dplyr::full_join(aug$nodes, by = "node", suffix = c("", ".new")) %>%
dplyr::mutate(nodeLabel = dplyr::coalesce(nodeLabel, nodeLabel.new)) %>%
dplyr::select(-nodeLabel.new)
cat(sprintf("After augmentation → Nodes: %s | Edges: %s\n",
nrow(nodes), nrow(edges)))
# (Re)write quick CSVs for inspection
readr::write_csv(nodes, "data_prepared/anc_nodes.csv")
readr::write_csv(edges, "data_prepared/anc_edges.csv")
# Build igraph on augmented data and save RData
graph <- igraph::graph_from_data_frame(edges, directed = TRUE, vertices = nodes)
cat(sprintf("Final graph → %s nodes | %s edges\n",
igraph::vcount(graph), igraph::ecount(graph)))
save(graph, nodes, edges, file = "data_prepared/mm2019_ancestors_only.RData")
cat("Saved:\n  - data_prepared/mm2019_ancestors_only.RData\n",
"  - data_prepared/anc_nodes.csv\n",
"  - data_prepared/anc_edges.csv\n")
####Horizontal Relationship ####
# ====  Horizontal-relationship helpers ====
library(dplyr); library(purrr); library(tidyr); library(readr); library(fs)
dir_create("generated")
# 1) spouses from co-parents
spouse_edges_from_coparents <- function(edges) {
fathers <- edges %>% filter(type == "has_father") %>% transmute(child = from, father = to)
mothers <- edges %>% filter(type == "has_mother") %>% transmute(child = from, mother = to)
cop <- fathers %>%
inner_join(mothers, by = "child") %>%
transmute(a = pmin(father, mother), b = pmax(father, mother)) %>%
filter(!is.na(a), !is.na(b), a != b) %>%
distinct()
cop %>% transmute(from = a, to = b, type = "spouse")
}
# 2) siblings from shared parents (full / maternal_half / paternal_half / any)
sibling_edges_from_parents <- function(edges) {
parent_children <- bind_rows(
edges %>% filter(type == "has_father") %>% transmute(parent = to, child = from, side = "paternal"),
edges %>% filter(type == "has_mother") %>% transmute(parent = to, child = from, side = "maternal")
)
if (nrow(parent_children) == 0) {
return(tibble(from = character(), to = character(), type = character()))
}
sib_pairs <- parent_children %>%
group_by(parent) %>%
summarise(children = list(sort(unique(child))), .groups = "drop") %>%
mutate(pairs = map(children, ~{
kids <- .x
if (length(kids) < 2) return(tibble(a = character(), b = character()))
as_tibble(t(combn(kids, 2))) |> rename(a = V1, b = V2)
})) %>%
select(-children) %>%
unnest(pairs)
if (nrow(sib_pairs) == 0) {
return(tibble(from = character(), to = character(), type = character()))
}
detail <- sib_pairs %>%
left_join(parent_children %>% select(parent, child, side),
by = c("parent" = "parent", "a" = "child")) %>% rename(side_a = side) %>%
left_join(parent_children %>% select(parent, child, side),
by = c("parent" = "parent", "b" = "child")) %>% rename(side_b = side) %>%
transmute(a, b, share = paste(sort(c(side_a, side_b)), collapse = "+")) %>%
distinct() %>%
count(a, b, share, name = "n_parents") %>%
mutate(sib_type = case_when(
n_parents >= 2 ~ "full",
share %in% "maternal+maternal" ~ "maternal_half",
share %in% "paternal+paternal" ~ "paternal_half",
TRUE ~ "any"
))
detail %>%
transmute(from = pmin(a, b), to = pmax(a, b), type = paste0("sibling_", sib_type)) %>%
distinct()
}
# 3) combined horizontal edges
build_horizontal_edges <- function(edges) {
bind_rows(
spouse_edges_from_coparents(edges),
sibling_edges_from_parents(edges)
) %>% distinct()
}
# 4) lookups
get_spouses <- function(qid, edges, nodes) {
spouses <- spouse_edges_from_coparents(edges)
tibble(spouse_id = unique(c(spouses$to[spouses$from == qid], spouses$from[spouses$to == qid]))) %>%
filter(!is.na(spouse_id)) %>%
left_join(nodes %>% transmute(qid = node, name = coalesce(nodeLabel, node)), by = c("spouse_id" = "qid"))
}
get_siblings <- function(qid, edges, nodes, type = c("any","full","maternal_half","paternal_half")) {
type <- match.arg(type)
sib_edges <- sibling_edges_from_parents(edges)
wanted_types <- if (type == "any") unique(sib_edges$type) else paste0("sibling_", type)
sib_edges %>%
filter(type %in% wanted_types) %>%
filter(from == qid | to == qid) %>%
transmute(sibling_id = if_else(from == qid, to, from), sib_edge_type = type) %>%
distinct() %>%
left_join(nodes %>% transmute(qid = node, name = coalesce(nodeLabel, node)), by = c("sibling_id" = "qid"))
}
# 5) small sample (optionally scoped to a seed's component)
sample_horizontal_relatedness <- function(edges, nodes, graph, seed_qid = NULL, n_each = 10) {
horiz <- build_horizontal_edges(edges)
if (!is.null(seed_qid)) {
comp <- igraph::components(graph)$membership; names(comp) <- igraph::V(graph)$name
seed_comp <- comp[[seed_qid]]
in_comp <- names(comp)[comp == seed_comp]
horiz <- horiz %>% filter(from %in% in_comp | to %in% in_comp)
}
decorate <- function(df) {
df %>%
left_join(nodes %>% transmute(qid = node, from_label = coalesce(nodeLabel, node)), by = c("from" = "qid")) %>%
left_join(nodes %>% transmute(qid = node, to_label   = coalesce(nodeLabel, node)), by = c("to"   = "qid")) %>%
select(type, from, from_label, to, to_label)
}
list(
spouses  = decorate(horiz %>% filter(type == "spouse")            %>% slice_head(n = n_each)),
siblings = decorate(horiz %>% filter(startsWith(type, "sibling")) %>% slice_head(n = n_each))
)
}
# 6) exports
export_horizontal_relationships <- function(edges, nodes, out_dir = "generated",
refresh_direct = FALSE) {
fs::dir_create(out_dir)
# (A) Inferred from your vertical structure
spouses_inf   <- spouse_edges_from_coparents(edges)            # type = "spouse"
siblings_inf  <- sibling_edges_from_parents(edges)             # type = "sibling_*"
# (B) Direct Wikidata (P26, P3373)
qids <- nodes$node
spouses_p26   <- spouse_edges_from_p26(qids,  use_cache = !refresh_direct)     # type = "spouse_p26"
siblings_p33  <- sibling_edges_from_p3373(qids, use_cache = !refresh_direct)   # type = "sibling_p3373"
# (C) Combine (keep provenance in `type`)
horiz_all <- dplyr::bind_rows(spouses_inf, siblings_inf, spouses_p26, siblings_p33) %>%
dplyr::distinct()
# (D) Write edge tables (separate + combined)
readr::write_csv(spouses_inf,  file.path(out_dir, "spouse_edges_inferred.csv"))
readr::write_csv(siblings_inf, file.path(out_dir, "sibling_edges_inferred.csv"))
readr::write_csv(spouses_p26,  file.path(out_dir, "spouse_edges_p26.csv"))
readr::write_csv(siblings_p33, file.path(out_dir, "sibling_edges_p3373.csv"))
readr::write_csv(horiz_all,    file.path(out_dir, "horizontal_edges_all_sources.csv"))
# (E) Per-person counts (bucket spouse vs sibling across all sources)
counts <- horiz_all %>%
tidyr::pivot_longer(cols = c(from, to), values_to = "qid") %>%
dplyr::mutate(rel_bucket = dplyr::case_when(
type %in% c("spouse", "spouse_p26") ~ "spouse",
grepl("^sibling", type)             ~ "sibling",
TRUE                                ~ "other"
)) %>%
dplyr::count(qid, rel_bucket, name = "n") %>%
tidyr::pivot_wider(names_from = rel_bucket, values_from = n, values_fill = 0) %>%
dplyr::left_join(nodes %>% dplyr::transmute(qid = node, name = dplyr::coalesce(nodeLabel, node)),
by = "qid") %>%
dplyr::relocate(qid, name)
readr::write_csv(counts, file.path(out_dir, "horizontal_counts_per_person.csv"))
# (F) Console summary
cat("Horizontal edges — inferred spouses:", nrow(spouses_inf),
"| inferred siblings:", nrow(siblings_inf), "\n")
cat("Horizontal edges — P26 spouses:", nrow(spouses_p26),
"| P3373 siblings:", nrow(siblings_p33), "\n")
cat("Combined unique horizontal edges:", nrow(horiz_all), "\n")
invisible(list(
spouses_inferred   = spouses_inf,
siblings_inferred  = siblings_inf,
spouses_p26        = spouses_p26,
siblings_p3373     = siblings_p33,
edges_all          = horiz_all,
counts             = counts
))
}
# Pick a seed by label or by Q-ID
pick_seed <- function(id_or_label) {
if (startsWith(id_or_label, "Q")) {
return(id_or_label)
} else {
# resolve label -> Q-ID (first exact match)
idx <- match(id_or_label, V(graph)$nodeLabel)
if (is.na(idx)) stop("No exact nodeLabel match found for: ", id_or_label)
return(V(graph)$name[idx])
}
}
# Build an induced subgraph of all ancestors reachable from the seed
subgraph_for_seed <- function(seed_id) {
# vertices reachable by following child -> parent (outgoing edges)
vids <- subcomponent(graph, v = seed_id, mode = "out")
induced_subgraph(graph, vids = vids)
}
# Compute generation depth from seed (0 = seed, 1 = parents, 2 = grandparents, ...)
depth_from_seed <- function(g, seed_id) {
d <- igraph::distances(g, v = seed_id, mode = "out")
dv <- as.numeric(d[1, ])
names(dv) <- V(g)$name
dv
}
# Nicely color father vs. mother edges
edge_color_map <- function(etype) ifelse(etype == "has_father", "#2c7fb8", "#f768a1")
#### #### 4. Seed subgraph & generation depth #####
# Purpose:
# - Choose one “seed” person (e.g., Stefan Quandt)
# - Build their ancestor subgraph (parents, grandparents, etc.)
# - Compute each person’s generation depth relative to the seed
# - Export summary CSVs for visualization or analysis
SEED_INPUT <- "Stefan Quandt"   # <-- You can change this to any name
seed_qid <- pick_seed(SEED_INPUT)
cat("Chosen seed:", SEED_INPUT, "→ Q-ID:", seed_qid, "\n")
g_sub <- subgraph_for_seed(seed_qid)
cat("Subgraph size:", vcount(g_sub), "nodes |", ecount(g_sub), "edges\n")
# 4a. sample around the current seed ====
samp <- sample_horizontal_relatedness(edges, nodes, graph, seed_qid = seed_qid, n_each = 10)
cat("\n--- SPOUSES (sample) ---\n"); print(samp$spouses)
cat("\n--- SIBLINGS (sample) ---\n"); print(samp$siblings)
# Per-person lookups:
cat("\n--- Spouses for seed ---\n"); print(get_spouses(seed_qid, edges, nodes))
cat("\n--- Siblings (any) for seed ---\n"); print(get_siblings(seed_qid, edges, nodes, type = "any"))
# 4b. Compute depth (generation) from the individual seed
depth_vec <- depth_from_seed(g_sub, seed_qid)
V(g_sub)$generation <- depth_vec[V(g_sub)$name]   # assign numeric generation values
V(g_sub)$generation[!is.finite(V(g_sub)$generation)] <- NA  # replace infinite values with NA
# 4c. Export the generation depth information to CSV
# ------------------------------------------------------------
library(tidyverse)
library(fs)
fs::dir_create("generated")
# Keep the full subgraph (for exporting everything)
g_sub_full <- g_sub
# Convert the depth vector into a tibble
# Use ALL vertices; fill NA for unreachable
all_qids <- igraph::V(g_sub_full)$name
generation_seed <- tibble::tibble(
qid = all_qids,
generation_from_seed = {
dv <- depth_vec[qid]                    # aligns by name
ifelse(is.finite(dv), as.integer(dv), NA_integer_)
}
)
# Extract node information (name, label, etc.)
nodes_export <- igraph::as_data_frame(g_sub_full, what = "vertices") %>%
tibble::as_tibble() %>%
dplyr::rename(qid = name) %>%
dplyr::select(qid, dplyr::any_of(c("label", "title")))
# Merge node attributes with generation info
nodes_with_generation <- nodes_export %>%
left_join(generation_seed, by = "qid")
# Summary of how many nodes exist in each generation
generation_summary <- nodes_with_generation %>%
group_by(generation_from_seed) %>%
summarise(n_nodes = n(), .groups = "drop") %>%
arrange(generation_from_seed)
# Save both detailed and summary tables
write_csv(nodes_with_generation, "generated/nodes_generation_from_seed.csv")
write_csv(generation_summary, "generated/generation_from_seed_summary.csv")
cat("✔ Exported generation_from_seed data to /generated folder\n")
# 4d. Compute true ancestry depth (distance from the root ancestors)
# Ensure we have an igraph object (works whether g_sub_full is igraph or tbl_graph)
g_ig <- if (inherits(g_sub_full, "igraph")) {
g_sub_full
} else {
tidygraph::as.igraph(g_sub_full)
}
# Roots = vertices with no incoming parent edges
roots <- which(igraph::degree(g_ig, mode = "in") == 0)
# Distances from each root to all vertices
dist_list <- lapply(roots, function(r) {
igraph::distances(g_ig, v = r, to = igraph::V(g_ig), mode = "out")
})
dist_mat <- do.call(rbind, dist_list)
# Minimum finite distance from any root (NA if unreachable)
depth_from_roots <- apply(dist_mat, 2, function(x) {
if (all(is.infinite(x))) NA_integer_ else as.integer(min(x[is.finite(x)]))
})
# Make sure names line up with vertex names (qid)
names(depth_from_roots) <- colnames(dist_mat)
# Add ancestry depth column to your node table and export
nodes_with_generations <- nodes_with_generation %>%
dplyr::mutate(depth_from_roots = depth_from_roots[qid])
readr::write_csv(
nodes_with_generations,
"generated/nodes_generation_with_ancestry_depth.csv"
)
cat("✔ Exported nodes_generation_with_ancestry_depth.csv (includes both seed-based and ancestry depth)\n")
####Full Graph to see the depth from roots ####
# SEED_INPUT <- "Stefan Quandt"        # still okay to keep a seed for a relative column
# seed_qid   <- pick_seed(SEED_INPUT)
# cat("Chosen seed:", SEED_INPUT, "→ Q-ID:", seed_qid, "\n")
#
# g_sub <- graph                         # <- FULL graph
# cat("Full graph size:", vcount(g_sub), "nodes |", ecount(g_sub), "edges\n")
#
# # ------------------ DEPTH FROM SEED (optional, NA if not reachable) ------------------
# depth_vec <- igraph::distances(g_sub, v = seed_qid, mode = "out")
# depth_vec <- as.numeric(depth_vec[1, ])
# names(depth_vec) <- igraph::V(g_sub)$name
#
# # Build from ALL vertices so every QID appears
# all_qids <- igraph::V(g_sub)$name
# generation_from_seed_tbl <- tibble::tibble(
#   qid = all_qids,
#   generation_from_seed = {
#     dv <- depth_vec[qid]
#     ifelse(is.finite(dv), as.integer(dv), NA_integer_)  # NA for nodes not reachable from seed
#   }
# )
#
# # ------------------ NODE ATTRIBUTES + FAMILY JOIN ------------------
# nodes_export <- igraph::as_data_frame(g_sub, what = "vertices") %>%
#   tibble::as_tibble() %>%
#   dplyr::rename(qid = name) %>%
#   # bring over label/group stored earlier
#   dplyr::select(qid, dplyr::any_of(c("nodeLabel","group","is_seed"))) %>%
#   # join family info from the original dataframe (df has id_wikidata, id_fam, name)
#   dplyr::left_join(
#     df %>% dplyr::select(id_wikidata, id_fam, name) %>% dplyr::distinct(),
#     by = c("qid" = "id_wikidata")
#   )
#
# # ------------------ ANCESTRY DEPTH FROM ROOTS (works for ALL) ------------------
# g_ig <- g_sub  # g_sub is already igraph
#
# roots <- which(igraph::degree(g_ig, mode = "in") == 0)
# dist_list <- lapply(roots, function(r) igraph::distances(g_ig, v = r, to = igraph::V(g_ig), mode = "out"))
# dist_mat  <- do.call(rbind, dist_list)
#
# depth_from_roots <- apply(dist_mat, 2, function(x) {
#   if (all(is.infinite(x))) NA_integer_ else as.integer(min(x[is.finite(x)]))
# })
# names(depth_from_roots) <- colnames(dist_mat)
#
# # Also handy: connected component id (lets you group families/components)
# comp_id <- igraph::components(g_ig)$membership
# names(comp_id) <- igraph::V(g_ig)$name
#
# # ------------------ MERGE & EXPORT (ONE CSV FOR ALL) ------------------
# nodes_all <- nodes_export %>%
#   dplyr::left_join(generation_from_seed_tbl, by = "qid") %>%
#   dplyr::mutate(
#     depth_from_roots = depth_from_roots[qid],
#     component_id     = comp_id[qid]
#   ) %>%
#   dplyr::relocate(qid, id_fam, name, nodeLabel, group, component_id,
#                   generation_from_seed, depth_from_roots)
#
# fs::dir_create("generated")
# readr::write_csv(nodes_all, "generated/all_nodes_with_depths.csv")
#
# cat("✔ Wrote one CSV with ALL QIDs → generated/all_nodes_with_depths.csv\n")
hr <- export_horizontal_relationships(edges, nodes)
# ------------------------------------------------------------
# 5) Optional: cap super-deep tails in the plot (for readability)
# ------------------------------------------------------------
MAX_GEN_SHOW <- 12
keep <- which(is.na(V(g_sub)$generation) | V(g_sub)$generation <= MAX_GEN_SHOW)
g_sub <- induced_subgraph(g_sub, vids = keep)
cat("Plotted subgraph (capped at", MAX_GEN_SHOW, "generations):",
vcount(g_sub), "nodes |", ecount(g_sub), "edges\n")
cat("Depth range (shown):",
min(V(g_sub)$generation, na.rm = TRUE), "to",
max(V(g_sub)$generation, na.rm = TRUE), "\n")
#### 5. Visualizations ####
dir.create("graphs", showWarnings = FALSE)
# libs for plotting (install if needed)
viz_pkgs <- c("ggraph", "ggplot2", "tidygraph", "visNetwork", "htmlwidgets")
lapply(viz_pkgs[!(viz_pkgs %in% installed.packages())], install.packages)
lapply(viz_pkgs, library, character.only = TRUE)
# Load what we just created
load("data_prepared/mm2019_ancestors_only.RData")   # gives: graph, nodes, edges
#  5a. Static hierarchy plot (fixed)
# Color father/mother via the edge type:
p <- ggraph(g_sub, layout = "sugiyama") +
geom_edge_link(aes(edge_colour = type), alpha = 0.6) +
geom_node_point(aes(color = group, size = ifelse(group == "rich 2019", 4, 2))) +
geom_node_text(
aes(label = ifelse(group == "rich 2019" | generation <= 2, nodeLabel, "")),
repel = TRUE, size = 3
) +
scale_edge_colour_manual(values = c(has_father = "#2c7fb8", has_mother = "#f768a1")) +
scale_size_identity() +
labs(
title = paste0("Ancestor tree (parents only) — seed: ",
V(g_sub)$nodeLabel[V(g_sub)$name == seed_qid]),
subtitle = "Edges: child → parent (blue = father, pink = mother)"
) +
theme_minimal()
print(p)
ggsave(filename = file.path("graphs", paste0("ancestors_", seed_qid, ".png")),
plot = p, width = 10, height = 7, dpi = 300)
cat("Saved static plot → graphs/", paste0("ancestors_", seed_qid, ".png"), "\n", sep = "")
# 5b.install once
# install.packages(c("visNetwork","htmlwidgets"))
library(visNetwork)
library(htmlwidgets)
# Ensure a folder exists for output
dir.create("graphs", showWarnings = FALSE, recursive = TRUE)
# We assume you already have:
#   - graph, nodes, edges loaded
#   - seed_qid (Q-ID of the chosen person)
#   - g_sub     (ancestor-only subgraph for that seed)
#   - V(g_sub)$generation set to depth (0 = seed)
# Build nodes dataframe for visNetwork
nodes_df <- data.frame(
id    = V(g_sub)$name,                                   # Q-ID
label = ifelse(is.na(V(g_sub)$nodeLabel) | V(g_sub)$nodeLabel=="",
V(g_sub)$name, V(g_sub)$nodeLabel),       # readable label
group = V(g_sub)$group,                                  # "rich 2019" / "ancestor"
level = as.integer(ifelse(is.finite(V(g_sub)$generation),
V(g_sub)$generation, 0)),       # hierarchy levels
title = paste0(
"<b>", V(g_sub)$nodeLabel, "</b>",
"<br/>Q-ID: ", V(g_sub)$name,
"<br/>Generation: ", V(g_sub)$generation
),                                                       # hover tooltip
stringsAsFactors = FALSE
)
# Build edges dataframe (color father/mother)
e <- igraph::as_data_frame(g_sub, what = "edges")
edges_df <- data.frame(
from   = e$from,
to     = e$to,
arrows = "to",
color  = ifelse(e$type == "has_father", "#2c7fb8", "#f768a1"),
title  = e$type,                                         # hover tooltip
smooth = FALSE,
stringsAsFactors = FALSE
)
# Make the widget
vis <- visNetwork(nodes_df, edges_df, width = "100%", height = "720px") %>%
visHierarchicalLayout(direction = "UD",                   # top (parents) down
levelSeparation = 120,
nodeSpacing = 180,
treeSpacing = 180,
sortMethod = "directed") %>%
visGroups(groupname = "rich 2019",
color = list(background = "#00b3b3", border = "#008080")) %>%
visGroups(groupname = "ancestor",
color = list(background = "#f0f0f0", border = "#bdbdbd")) %>%
visOptions(highlightNearest = TRUE,
nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)) %>%
visLegend() %>%
visEdges(width = 2) %>%
visPhysics(stabilization = FALSE)
# Show in the Viewer pane
vis
# Save to a standalone HTML (double-click to open, or share)
seed_label <- nodes_df$label[match(seed_qid, nodes_df$id)]
out_html <- sprintf("graphs/ancestor_%s.html",
gsub("\\s+", "_", seed_label, perl = TRUE))
saveWidget(vis, file = out_html, selfcontained = TRUE)
# Open in your default browser (macOS)
browseURL(out_html)
###The End
